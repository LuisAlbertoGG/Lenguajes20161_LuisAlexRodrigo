
#lang plai

#|
 #pow - Define la funci´on pow tal que toma dos n´umeros enteros positivos z y w y regresa el numero que se
 #obtiene de elevar el numero z a la potencia w, i.e.
|#

(define (pow x y)

  ;caso base cuando x^0 =1
  (cond
    [(= y 0)1] ; si x^0 =0
          ;base potencias de la base *exponente-1
    [else (* x(pow x (- y 1)))]));llamada recursiva
    
    #|
    # >(test (pow 2 7) 128)
    # >(test (pow 5 1) 5)
    # >(test (pow 8 0) 1)
    # >(test (pow 7 3) 343)
    # >(test (pow 3 7) 2187)
    #|
  
  #|
  #
  #average - Dado una lista no vac´ıa de n´umeros, regresar el promedio de esta, i.e.
  |#
  (define (average lista)
  (define (suma lista) 
  (cond
    [(empty? lista) 0] ;si la lista es vacia
    [(= 1(length lista)) (car lista)]
    ;(+(car lista)(pro (cdr lista)))
    [ (+(car lista)(suma (cdr lista)))]))
  (/(suma lista )(length lista)))
  
  #|
  # >(test(average '( 10 9 8 7) )8.5)
  # >(test(average '( 10 9 10 10) )9.75)
  # >(test(average '( 10 ) )10)
  # >(test(average '( 10 8 6) )8)
  # >(test(average '( 10 8 12) )10)
  #|#
  
  
  
  #|
  #Dadas dos listas, regresar una lista cuyos elementos son listas de tama˜nos dos, tal que par la i-´esima
  #lista, el primer elemento es el i-´esimo de la primera lista original y el segundo elemento es el i-´esimo de la
  #segunda lista original, si una lista es de menor tama˜no que la otra, la lista resultante es del tama˜no de la
  #menor, y si una de las listas es vac´ıa, regresar una lista vac´ıa, i
  |#
  
  (define (zip L R)
  (cond
    [(and (< 1(length L)) (< 1(length R)))
     (list (list(car L ) (car R))
           (list (car (cdr L)) (car (cdr R))))]
    [else '()]))


;Regreso la evaluación de la función dada, encadenada de los elementos de la lista dada.

(define(reduce func lst)
  [cond
    [(empty? lst) '()] ; Caso base: Sí la lista está vacia.
    [(empty? (cdr lst)) (car lst)]; Caso base: Sí solo tiene un elemento.
    ;Evaluo la función del car de lst con la llamada recursiva del cdr de lst.
    [else( func (car lst) (reduce func (cdr lst)) )]])

#|
(test (reduce + '(1) ) 1)
(test (reduce + '() ) '())
(test (reduce + '(1 2) ) 3)
(test (reduce + '(1 2 3) ) 6)
(good (reduce + '(1 2 3 4)) 10 10 "at line 21")
|#


  #|
  # mconcat - Dado dos listas, regresa la concatenación de ambas listas.
  |#

(define(mconcat lst lst1)
  [cond
    [(empty? lst) lst1] ;si la lista lst es vacia.
    [(empty? lst1) lst] ;si la lista lst1 es vacia.
    [else(cons(car lst) (mconcat (cdr lst) lst1))]]) ;Se crea una lista con el car de lst y la llamada recursiva del cdr de lst y lst1.

#|
(test (mconcat '() '() ) '())
(test (mconcat '() '(1) ) '(1))
(test (mconcat '(2) '(1) ) '(2 1))
(test (mconcat '(1 2) '(1) ) '(1 2 1))
(test (mconcat '(1 2) '(3 4) ) '(1 2 3 4))
|#


#|
#Regresa una lista con la aplicación de la función a cada elemento de la lista.
|#

(define(mmap func lst)
  [cond
    [(empty? lst) '()] ;Caso base: sí la lista está vacia.
    [else( cons (func(car lst)) (mmap func (cdr lst))) ]]) ;Hago una lista con la aplicación de la
;función al car de la lista dada y la llamada recursiva con la función aplicada al cdr de la lista dada.

 #|
    # (test (mmap car '()) '())
    # (test (mmap car '((1 2))) '(1))
    # (test (mmap car '((1 2) (2 3))) '(1 2))
    # (test (mmap cdr '((1 2) (2 3))) '((2) (3)))
    # (test (mmap cdr '((1 2) (2 3) (3 4))) '((2) (3) (4)))
 |#
